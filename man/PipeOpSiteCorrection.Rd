% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PipeOpSiteCorrection.R
\name{PipeOpSiteCorrection}
\alias{PipeOpSiteCorrection}
\title{Site-/Batch-Effect Correction PipeOp (block-specific, lean)}
\format{
R6 class inheriting from \link[mlr3pipelines:PipeOpTaskPreproc]{mlr3pipelines::PipeOpTaskPreproc}
}
\value{
An \link[mlr3:Task]{mlr3::Task} with harmonized features.
Site/covariate columns referenced by \code{site_correction} are dropped unless \code{keep_site_col = TRUE}.
}
\description{
\code{PipeOpSiteCorrection} removes unwanted \strong{site / batch effects} from
\strong{multi-block data} inside an \emph{mlr3} pipeline. Behavior is controlled by
two named lists (by \strong{block}):
\itemize{
\item \code{site_correction}: block → \strong{specification of site/batch and optional covariates}.
\itemize{
\item For \code{"partial_corr"}: a \strong{character vector of columns} (categorical site and/or numeric covariates).
\item For \code{"dir"}: a \strong{single categorical column} (protected attribute).
\item For \code{"combat"} (\strong{new structured format}): a \strong{list} with fixed elements
\verb{list(site = <character(1)>, covariates = <character()>)}.
The \code{site} column is mapped to ComBat’s \code{batch}; the \code{covariates} are
encoded into a model matrix and passed as \code{mod}.
\emph{(Backward compatible: if a single string is provided, it is treated as \code{site}.)}
}
\item \code{method}: \code{block -> "partial_corr" | "combat" | "dir"}. Missing blocks
default to \code{"partial_corr"}.
}

Blocks \strong{absent} from \code{site_correction} are \strong{left unchanged}.
}
\details{
\strong{Partial correlation (\code{"partial_corr"})}
\itemize{
\item If the site spec is a \strong{single categorical} column, we build a dummy-coded
design with an intercept and keep a stable column layout across train/predict.
At predict-time, \strong{unseen site labels} are treated as \strong{no-op rows} (i.e.,
zero design contribution) or can be mapped to baseline if you set
\code{unknown_site = "baseline"}.
\item If the site spec is \strong{multiple columns} (e.g., PRS PCs) or numeric,
we construct the design as \code{cbind(1, Z)} via \code{model.matrix(~ .)}.
\item We solve a ridge-stabilized normal equation for the site effects and
subtract them; optional mean re-add (\code{zero_center = FALSE} by default).
}

\strong{ComBat (\code{"combat"}, via \pkg{neuroCombat}) — now with \code{mod} support}
\itemize{
\item Trains using \code{neuroCombat(dat = t(X), batch = site, mod = MM, ...)}, where
\code{MM = model.matrix(~ ., data = covariates)}; character covariates are
auto-factorized. ComBat accepts \strong{one} batch vector, but \strong{many covariates}.
We store the returned \code{estimates}, the valid batch levels, the \code{site_var},
and the list of \code{covariates}. :contentReference[oaicite:2]{index=2}
\item At predict, we apply \code{neuroCombatFromTraining(dat, batch, estimates)}.
The upstream function \strong{does not support} supplying \code{mod} for new data;
if estimates were trained with \code{mod}, it uses an internal mean-imputation
of the training covariate effects. Unseen batches can be handled with
\code{combat_unknown = "noop"} (skip) or \code{"baseline"} (map to \code{ref_batch}). :contentReference[oaicite:3]{index=3}
}

\strong{DIR (\code{"dir"}, via \pkg{fairmodels})}
\itemize{
\item Applies distribution repair per block with the given \code{lambda}.
}

The operator preserves targets, reconstructs a backend with stable row ids,
and (by default) \strong{drops} all site/covariate columns referenced in \code{site_correction}
unless \code{keep_site_col = TRUE}.
}
\section{Construction}{

\preformatted{
PipeOpSiteCorrection$new(
  id         = "sitecorr",
  param_vals = list()
)
}
}

\section{Tunable hyper-parameters (\code{self$param_set})}{

\describe{
\item{\strong{Core}}{
\itemize{
\item \code{blocks} (\code{list()}): Named list of \strong{feature vectors} per block
(non-numeric features are auto-dropped). If \code{NULL}, all numeric
features form one block \code{".all"}.
\item \code{site_correction} (\code{list()}): Named list \strong{by block}. For \code{"combat"}
use \verb{list(site=<char1>, covariates=<char_vec>)}; for other methods,
character vectors as described above. Missing block ⇒ no correction.
\item \code{method} (\code{list()}): Named list \code{block -> "partial_corr"|"combat"|"dir"}.
Missing block ⇒ \code{"partial_corr"}.
\item \code{keep_site_col} (\code{logical(1)}): Keep all site/covariate columns referenced by
\code{site_correction}? Default \code{FALSE}.
}
}
\item{\strong{Partial-correlation}}{
\itemize{
\item \code{unknown_site} (\code{"other"|"baseline"}): Predict-time strategy for an
unseen \strong{categorical} site under \code{"partial_corr"}. Default \code{"other"}.
\item \code{zero_center} (\code{logical(1)}): Re-add grand means? Default \code{FALSE}.
\item \code{revertflag} (\code{logical(1)}): Add instead of subtract the site effect.
\item \code{regularization} (\code{numeric(1)}): Ridge penalty to stabilize the site
regression (\code{0} ⇒ internally \code{1e-6}).
\item \code{subgroup} (\code{logical()}/\code{integer()}): Optional row subset for fitting.
}
}
\item{\strong{ComBat (neuroCombat)}}{
\itemize{
\item \code{eb} (\code{logical(1)}): Empirical Bayes shrinkage. Default \code{TRUE}.
\item \code{mean_only} (\code{logical(1)}): Adjust means only. Default \code{FALSE}.
\item \code{ref_batch} (\code{character(1)} or \code{NULL}): Optional reference.
\item \code{combat_unknown} (\code{"noop"|"baseline"}): Predict-time policy for
unseen batches. Default \code{"noop"}.
}
}
\item{\strong{DIR (fairmodels)}}{
\itemize{
\item \code{lambda} (\code{numeric(1)} in [0,1]): Repair strength. Default \code{0.5}.
}
}
\item{\strong{Misc}}{
\itemize{
\item \code{verbose} (\code{logical(1)}): Emit log messages via \pkg{lgr}.
}
}
}
}

\section{State (after \verb{$train()})}{

A named list with:
\itemize{
\item \code{blocks}: Named list of \strong{effective} block feature vectors used for training
(with any referenced site/covariate columns removed).
\item \code{per_block}: Named list with one entry per corrected block:
\itemize{
\item \code{method}: \code{"partial_corr"|"combat"|"dir"}.
\item \code{site_cols}: Character vector of all referenced site/covariate columns for that block.
\item \code{design_kind}, \code{design_cols}, \code{beta}, \code{means}, \code{zero_center}, \code{revert} (partial_corr).
\item \code{site_var} (\code{character(1)}), \code{covariates} (\code{character()}), \code{site_lvls},
\code{estimates}, \code{ref_batch} (combat).
\item \code{lambda}, \code{site_lvls} (dir).
}
\item \code{unknown_site}, \code{keep_site_col}.
}
}

\section{Methods}{

\describe{
\item{\verb{$train(task)}}{Fit correction parameters from an \link[mlr3:Task]{mlr3::Task}.}
\item{\verb{$predict(task)}}{Apply the learnt correction and return a harmonized \code{Task}.}
}
}

\examples{
\dontrun{
library(mlr3)
library(mlr3pipelines)
library(data.table)
task = tsk("pima")
# fake columns
task$data[, site := sample(LETTERS[1:3], .N, TRUE)]
task$data[, Age := rnorm(.N)]
task$data[, Sex := sample(c("F", "M"), .N, TRUE)]

po_site = PipeOpSiteCorrection$new(param_vals = list(
  blocks = list(num = task$feature_names),
  site_correction = list(
    num = list(site = "site", covariates = c("Age", "Sex")) # <-- ComBat with mod
  ),
  method = list(num = "combat"),
  keep_site_col = FALSE,
  combat_unknown = "noop"
))
g = po("copy") \%>>\% po_site
g$train(task)
}

}
\seealso{
\link[mlr3pipelines:PipeOpTaskPreproc]{mlr3pipelines::PipeOpTaskPreproc},
\link[neuroCombat:neuroCombat]{neuroCombat::neuroCombat} / \link[neuroCombat:neuroCombatFromTraining]{neuroCombat::neuroCombatFromTraining},
\link[fairmodels:disparate_impact_remover]{fairmodels::disparate_impact_remover}.

Other PipeOps: 
\code{\link{PipeOpMBsPLS}},
\code{\link{PipeOpTargetLabelFilter}}
}
\concept{PipeOps}
\section{Super classes}{
\code{\link[mlr3pipelines:PipeOp]{mlr3pipelines::PipeOp}} -> \code{\link[mlr3pipelines:PipeOpTaskPreproc]{mlr3pipelines::PipeOpTaskPreproc}} -> \code{PipeOpSiteCorrection}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PipeOpSiteCorrection-new}{\code{PipeOpSiteCorrection$new()}}
\item \href{#method-PipeOpSiteCorrection-clone}{\code{PipeOpSiteCorrection$clone()}}
}
}
\if{html}{\out{
<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="help"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-help'><code>mlr3pipelines::PipeOp$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="predict"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-predict'><code>mlr3pipelines::PipeOp$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="print"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-print'><code>mlr3pipelines::PipeOp$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="train"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-train'><code>mlr3pipelines::PipeOp$train()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PipeOpSiteCorrection-new"></a>}}
\if{latex}{\out{\hypertarget{method-PipeOpSiteCorrection-new}{}}}
\subsection{Method \code{new()}}{
Create a new \code{PipeOpSiteCorrection} instance.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PipeOpSiteCorrection$new(id = "sitecorr", param_vals = list())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{\code{character(1)} Identifier for the new object. Default: \code{"sitecorr"}.}

\item{\code{param_vals}}{\code{list()} Named list of hyper-parameter values overriding defaults.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PipeOpSiteCorrection-clone"></a>}}
\if{latex}{\out{\hypertarget{method-PipeOpSiteCorrection-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PipeOpSiteCorrection$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
