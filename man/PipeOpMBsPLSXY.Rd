% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PipeOpMBsPLSXY.R
\name{PipeOpMBsPLSXY}
\alias{PipeOpMBsPLSXY}
\title{Supervised multi-block sPLS treating the target as an extra block}
\value{
A \code{PipeOpMBsPLSXY} that appends columns \code{LVk_<block>} for
each X-block.
}
\description{
\strong{PipeOpMBsPLSXY} is a supervised variant of MB-sPLS. During training, the
target (\eqn{Y}) is appended as its own block alongside the input blocks
\eqn{X_1,\dots,X_B}, so that extracted components maximize correlation
between X-blocks and Y. For downstream learners, only the \strong{X-side} latent
scores (LVs) are output (no Y leakage).

\strong{Handling encoded column names.} If upstream encoding expands/renames factors
into dummy columns like \code{"base.level"} (e.g., via
\code{PipeOpEncode(method = "treatment" | "one-hot")}), you may keep using the
\strong{base names} in \code{blocks} (e.g., \code{"MINI_dx"}). At \verb{$train()}, base names are
expanded to the actual post-encoding columns via regex \code{^<base>(\\.|$)}.
The resolved names are stored and reused at prediction; any missing columns are
filled with zeros.

For classification tasks, Y is internally one-hot encoded (no intercept).
You can replicate the target block via \code{y_rep} to increase its weight in the
objective.

\strong{Sparsity constraints.} Either provide a full \code{c_matrix} (rows = blocks
including target, columns = components), or use per-block \code{c_<block>}
parameters plus \code{c_target} for the target block.
}
\details{
Supervised Multi-Block Sparse PLS (MB-sPLS-XY) Transformer
}
\section{State after training}{

\describe{
\item{\code{blocks_x}}{Resolved X-blocks (numeric, non-constant features).}
\item{\code{ncomp}}{Number of extracted components.}
\item{\code{weights_x}, \code{loadings_x}}{Lists per component with weights/loadings per X-block.}
\item{\code{performance_metric}}{\code{"mac"} (mean absolute correlation) or \code{"frobenius"}.}
}
}

\section{Prediction}{

During \verb{$predict()}, X-scores are computed component-wise with deflation and
returned as new columns \code{LVk_<block>}. The Y-block is not needed. Any
columns that existed at training but are missing at prediction are created
as all-zero columns.
}

\section{Parameters}{

Hyperparameters are defined in the object's \code{param_set} and can be set
via \code{param_vals}.
}

\seealso{
\link{PipeOpMBsPLS} for the unsupervised variant,
\link[mlr3pipelines:mlr_pipeops_encode]{mlr3pipelines::PipeOpEncode} for post-encoding column names.
}
\keyword{internal}
\section{Super classes}{
\code{\link[mlr3pipelines:PipeOp]{mlr3pipelines::PipeOp}} -> \code{\link[mlr3pipelines:PipeOpTaskPreproc]{mlr3pipelines::PipeOpTaskPreproc}} -> \code{PipeOpMBsPLSXY}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{blocks}}{(\code{list}) Named base names of X-blocks (resolved post-encoding during training).}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PipeOpMBsPLSXY-new}{\code{PipeOpMBsPLSXY$new()}}
\item \href{#method-PipeOpMBsPLSXY-clone}{\code{PipeOpMBsPLSXY$clone()}}
}
}
\if{html}{\out{
<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="help"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-help'><code>mlr3pipelines::PipeOp$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="predict"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-predict'><code>mlr3pipelines::PipeOp$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="print"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-print'><code>mlr3pipelines::PipeOp$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="train"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-train'><code>mlr3pipelines::PipeOp$train()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PipeOpMBsPLSXY-new"></a>}}
\if{latex}{\out{\hypertarget{method-PipeOpMBsPLSXY-new}{}}}
\subsection{Method \code{new()}}{
Creates a new PipeOpMBsPLSXY instance.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PipeOpMBsPLSXY$new(id = "mbsplsxy", blocks, param_vals = list())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{\code{character(1)} Identifier (default \code{"mbsplsxy"}).}

\item{\code{blocks}}{Named list mapping block names to base feature names (required).}

\item{\code{param_vals}}{Initial \code{param_set} values.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new PipeOpMBsPLSXY.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PipeOpMBsPLSXY-clone"></a>}}
\if{latex}{\out{\hypertarget{method-PipeOpMBsPLSXY-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PipeOpMBsPLSXY$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
