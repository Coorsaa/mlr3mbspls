% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mbspls_eval_new_data.R
\name{mbspls_eval_new_data}
\alias{mbspls_eval_new_data}
\title{Evaluate MB-sPLS on New Data (EV per block/component, MAC, scores, weights)}
\usage{
mbspls_eval_new_data(gl, task, mbspls_id = NULL)
}
\arguments{
\item{gl}{(\code{GraphLearner})\cr A \strong{trained} graph learner containing a
\code{PipeOpMBsPLS} node.}

\item{task}{(\code{Task})\cr An \pkg{mlr3} task with \strong{new} data to evaluate on.
The graph’s preprocessing will be applied automatically.}

\item{mbspls_id}{(\code{character(1)} | \code{NULL})\cr Optional id of the MB-sPLS node
in the graph. If \code{NULL} (default), the first node inheriting from
\code{PipeOpMBsPLS} is used. If multiple nodes are present, the first is chosen
with a warning unless \code{mbspls_id} is supplied.}
}
\value{
\code{list} with the following elements (all computed on the \strong{new} data):
\itemize{
\item \code{ev_block} (\verb{matrix [ncomp × n_blocks]}): explained variance per block and component.
\item \code{ev_comp}  (\code{numeric [ncomp]}): total explained variance per component (across blocks).
\item \code{mac_comp} (\code{numeric [ncomp]}): objective per component on new data
(MAC or Frobenius, matching the trained operator).
\item \code{T_mat} (\verb{matrix [n_obs × (ncomp*n_blocks)]}): block scores; columns
ordered as \code{LV1_<block1>, …, LV1_<blockB>, LV2_<block1>, …}.
  \item \code{blocks} (\code{character [n_blocks]}): block names (for convenience).
\item \code{weights} (\code{list}): trained weights \eqn{w_b^{(k)}}\; list-of-lists:
component → block → named numeric vector (feature weights).
\item \code{loadings} (\code{list}): trained loadings \eqn{p_b^{(k)}} used for deflation.
\item \code{blocks_map} (\code{list}): mapping block → feature names (training).
\item \code{ncomp} (\code{integer(1)}): number of retained components.
\item \code{perf_metric} (\code{character(1)}): \code{"mac"} or \code{"frobenius"} (from training).
}
}
\description{
Runs a trained \pkg{mlr3} graph that contains a \code{PipeOpMBsPLS} on a \strong{new}
\code{Task} and returns \strong{evaluation metrics computed on the new data}:
block-wise explained variances per component, component-wise totals, the
latent-correlation objective (MAC or Frobenius), and the block scores.

Internally, this function temporarily attaches a logging environment to the
MB-sPLS node (via its \code{log_env} parameter), calls \code{gl$predict(task)},
retrieves the payload written by the operator, and augments it with the
\strong{trained} weights/loadings/blocks from the fitted model.

This ensures perfect parity with the training/prediction implementation
(deflation order, preprocessing upstream in the graph, etc.).
}
\details{
The function \strong{does not} modify the learner permanently. Any existing
\code{log_env} on the MB-sPLS node is restored after the call.
}
\section{Errors}{

An error is thrown if the graph has no \code{PipeOpMBsPLS} node, if the learner is
untrained, or if the MB-sPLS node did not log a payload (e.g., because the
id was wrong).
}

\examples{
\dontrun{
# Assume `gl` is a trained GraphLearner with a PipeOpMBsPLS node and
# `task_new` is an mlr3::Task with new data:
res = mbspls_eval_new_data(gl, task_new)

# Per-block explained variances on new data:
res$ev_block

# Per-component totals and MAC:
res$ev_comp
res$mac_comp

# Access trained weights for LC_02, block "mri":
res$weights[["LC_02"]][["mri"]]
}

}
\seealso{
\link[mlr3pipelines:mlr_learners_graph]{mlr3pipelines::GraphLearner}, \link{PipeOpMBsPLS}
}
