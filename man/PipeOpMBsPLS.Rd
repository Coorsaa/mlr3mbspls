% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PipeOpMBsPLS.R
\name{PipeOpMBsPLS}
\alias{PipeOpMBsPLS}
\title{PipeOp \code{mbspls}: extract up to \code{ncomp} orthogonal latent
components from multiple data blocks}
\value{
A \code{PipeOpMBsPLS} that outputs either only \code{LVk_<block>} columns
(default) or the original features plus appended LV columns (if \code{append=TRUE}).
}
\description{
\strong{PipeOpMBsPLS} fits \emph{sequential} MB-sPLS models and appends one
latent variable (LV) per block and component to the task’s backend.
After each component the corresponding rank-1 structure is removed
(block-wise score deflation in the sense of Westerhuis et al., 2001),
ensuring that successive LVs are orthogonal within every block.

The training objective is controlled by \code{performance_metric}:
\itemize{
\item \code{"mac"}: mean absolute correlation (average of \eqn{|r|}
across all block-score pairs) per component;
\item \code{"frobenius"}: Frobenius norm of the block-score correlation
matrix \eqn{\sqrt{\sum r^2}}.
}
We refer to this scalar as the \emph{latent correlation}.

During prediction, the same criterion (MAC/Frobenius) and explained variances
are computed on test data and, if \code{log_env} is provided, a compact
payload is written to \code{log_env$last}. Optionally, \emph{prediction-side
validation tests} can be requested (permutation or bootstrap; see Parameters).

The operator is a pure transformer: it performs no internal resampling,
tuning or preprocessing. Hyper-parameters such as the L¹ sparsity levels
\eqn{c_\mathrm{block}} are tuned externally (e.g., with \pkg{mlr3tuning}).
}
\details{
Multi-Block Sparse Partial Least Squares (MB-sPLS) Transformer
}
\section{State (after training)}{

\describe{
\item{\code{blocks}}{Named list mapping block names to feature column IDs.}
\item{\code{weights}}{List of length \code{ncomp}; block-specific weight vectors \eqn{w_b^{(k)}}.}
\item{\code{loadings}}{List of block loadings \eqn{p_b^{(k)}} used for deflation.}
\item{\code{ncomp}}{Number of components retained.}
\item{\code{obj_vec}}{Objective values (MAC/Frobenius) per component (training).}
\item{\code{latent_cor_train}}{Objective value of the last retained component (training).}
\item{\code{ev_block}}{Training explained variance per block (rows = components, cols = blocks).}
\item{\code{ev_comp}}{Training explained variance per component (summed across blocks).}
\item{\code{p_values}}{Permutation p-values per component if enabled during training.}
\item{\code{performance_metric}}{\code{"mac"} or \code{"frobenius"}.}
\item{\code{c_matrix}}{If provided/derived, the block-by-component sparsity matrix.}
\item{\code{T_mat}}{Training score matrix (per-component deflation applied);
columns ordered \code{LV1_<block1>, ..., LV1_<blockB>, LV2_<block1>, ...}.}
\item{\code{weights_stable}}{Optional stability-filtered weights (from the bootstrap PipeOp).}
}
}

\section{Prediction-side logging (\code{log_env$last})}{

A list containing:
\itemize{
\item \code{mac_comp}: numeric vector (length \code{ncomp}) with test MAC/Frobenius per component,
\item \code{ev_block}: matrix \code{(ncomp × n_blocks)} with test per-block explained variances,
\item \code{ev_comp}: numeric vector \code{(ncomp)} with test per-component EV (summed across blocks),
\item \code{T_mat}: test scores \code{(n_test × (ncomp * n_blocks))} with the same column order as training,
\item \code{blocks}: character vector with block names,
\item \code{perf_metric}: objective used (\code{"mac"} or \code{"frobenius"}),
\item \code{time}: POSIXct timestamp,
\item \code{val_test_p}: (if \code{val_test = "permutation"} or \code{"bootstrap"}) per-component p-values,
\item \code{val_test_stat}: (if available) observed test statistic per component,
\item \code{val_bootstrap}: (if \code{val_test = "bootstrap"}) data.table with
observed statistic, bootstrap mean/SE, p-value, and CI per component.
}
}

\section{Parameters}{

}

\section{Construction}{

\code{PipeOpMBsPLS$new(id = "mbspls", blocks, param_vals = list())}
}

\section{Methods}{

\itemize{
\item \verb{$new(id, blocks, param_vals)} : Initialize the PipeOpMBsPLS.
}
}

\section{Fields}{

\itemize{
\item \code{blocks} : Named list mapping block names to character vectors of feature names. Set during initialization.
}
}

\seealso{
Other PipeOps: 
\code{\link{PipeOpSiteCorrection}},
\code{\link{PipeOpTargetLabelFilter}}
}
\concept{PipeOps}
\keyword{internal}
\section{Super classes}{
\code{\link[mlr3pipelines:PipeOp]{mlr3pipelines::PipeOp}} -> \code{\link[mlr3pipelines:PipeOpTaskPreproc]{mlr3pipelines::PipeOpTaskPreproc}} -> \code{PipeOpMBsPLS}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{blocks}}{Named list mapping block names to character vectors of feature names.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PipeOpMBsPLS-new}{\code{PipeOpMBsPLS$new()}}
\item \href{#method-PipeOpMBsPLS-clone}{\code{PipeOpMBsPLS$clone()}}
}
}
\if{html}{\out{
<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="help"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-help'><code>mlr3pipelines::PipeOp$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="predict"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-predict'><code>mlr3pipelines::PipeOp$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="print"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-print'><code>mlr3pipelines::PipeOp$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3pipelines" data-topic="PipeOp" data-id="train"><a href='../../mlr3pipelines/html/PipeOp.html#method-PipeOp-train'><code>mlr3pipelines::PipeOp$train()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PipeOpMBsPLS-new"></a>}}
\if{latex}{\out{\hypertarget{method-PipeOpMBsPLS-new}{}}}
\subsection{Method \code{new()}}{
Initialize the PipeOpMBsPLS.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PipeOpMBsPLS$new(id = "mbspls", blocks, param_vals = list())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{character(1). Identifier of the resulting object.}

\item{\code{blocks}}{named list. Map of block names to feature column names.}

\item{\code{param_vals}}{named list. List of hyperparameter settings.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PipeOpMBsPLS-clone"></a>}}
\if{latex}{\out{\hypertarget{method-PipeOpMBsPLS-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PipeOpMBsPLS$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
